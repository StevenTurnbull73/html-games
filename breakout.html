<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Breakout — Classic & Easy Toggle</title>
<style>
  :root { --bg:#000; --fg:#fff; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--fg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; height:100%; }
  .wrap { display:grid; place-items:center; height:100%; gap:8px; }
  .topbar {
    width:800px; display:flex; justify-content:flex-start; align-items:center;
    font-size:14px; letter-spacing:1px; user-select:none;
  }
  .mode { display:flex; gap:8px; }
  .mode button {
    background:#111; color:#fff; border:1px solid #666; padding:4px 8px; cursor:pointer;
  }
  .mode button.active { background:#333; border-color:#aaa; }
  #frame { position:relative; border:2px solid #666; box-shadow:0 0 0 8px #222 inset; width:800px; background:#000; padding:8px; }
  #screen { display:block; background:#000; width:800px; height:600px; image-rendering: pixelated; }
  .hud { width:800px; display:flex; justify-content:space-between; letter-spacing:1px; user-select:none; font-size:14px; }
  .hint { opacity:.7; width:800px; font-size:12px; text-align:center; }
  .overlay {
    position:absolute; inset:8px;
    display:none; align-items:center; justify-content:center; flex-direction:column;
    background: rgba(0,0,0,0.85); color:#fff; text-align:center;
    border:1px solid #666;
  }
  .overlay.show { display:flex; }
  .title { font-size:32px; letter-spacing:2px; margin-bottom:8px; }
  .small { font-size:14px; opacity:.9; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="mode">
        <button id="btnClassic" class="active" aria-pressed="true">CLASSIC</button>
        <button id="btnEasy" aria-pressed="false">EASY</button>
      </div>
    </div>
    <div class="hud"><span id="scoreLbl">SCORE 0000</span><span id="livesLbl">BALLS 3</span></div>
    <div id="frame">
      <canvas id="screen" width="800" height="600"></canvas>
      <div id="winOverlay" class="overlay">
        <div class="title">CONGRATULATIONS!</div>
        <div id="winScore" style="margin-bottom:12px;">SCORE 0000</div>
        <div class="small">You’ve cleared the wall.</div>
        <div class="small">Press SPACE to play again.</div>
      </div>
      <div id="overOverlay" class="overlay">
        <div class="title">GAME OVER</div>
        <div id="overScore" style="margin-bottom:12px;">SCORE 0000</div>
        <div class="small">Press SPACE to try again.</div>
      </div>
    </div>
    <div class="hint">ARROWS: move | SPACE: launch/serve | R: restart — first keypress enables sound</div>
  </div>
<script>
(() => {
  const W=800,H=600, PLAY_L=10, PLAY_T=10, PLAY_R=W-10, PLAY_B=H-10;
  const canvas = document.getElementById('screen');
  const ctx = canvas.getContext('2d', { alpha:false });
  const scoreLbl = document.getElementById('scoreLbl');
  const livesLbl = document.getElementById('livesLbl');
  const winOverlay = document.getElementById('winOverlay');
  const winScore = document.getElementById('winScore');
  const overOverlay = document.getElementById('overOverlay');
  const overScore = document.getElementById('overScore');
  const btnClassic = document.getElementById('btnClassic');
  const btnEasy = document.getElementById('btnEasy');

  // --- WebAudio (shared) ---
  let actx = null, masterGain = null;
  let soundEnabled = false;
  function ensureAudio(){
    if (soundEnabled) return;
    try{
      actx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = actx.createGain();
      masterGain.gain.value = 0.08;
      masterGain.connect(actx.destination);
      soundEnabled = true;
    }catch(e){}
  }
  function beep({freq=440, dur=0.06, type='square', attack=0.001, decay=0.04, vol=1.0}){
    if (!soundEnabled) return;
    const t0 = actx.currentTime;
    const osc = actx.createOscillator();
    const g = actx.createGain();
    osc.type = type; osc.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(vol, t0 + attack);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + attack + decay + dur);
    osc.connect(g); g.connect(masterGain);
    osc.start(t0); osc.stop(t0 + attack + decay + dur + 0.02);
  }
  function sweep({from=440,to=880,dur=0.25,type='square',vol=1.0}){
    if(!soundEnabled) return;
    const t0 = actx.currentTime;
    const osc = actx.createOscillator();
    const g = actx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(from, t0);
    osc.frequency.linearRampToValueAtTime(to, t0+dur);
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(vol, t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    osc.connect(g); g.connect(masterGain);
    osc.start(t0); osc.stop(t0+dur+0.02);
  }
  const sounds = {
    wall:   () => beep({freq: 520, dur:0.03, type:'square', vol:0.8}),
    paddle: (rel=0) => beep({freq: 300 + Math.abs(rel)*200, dur:0.04, type:'square', vol:0.9}),
    brick:  () => beep({freq: 800, dur:0.035, type:'square', vol:0.7}),
    life:   () => { beep({freq: 220, dur:0.12, type:'triangle', vol:0.8}); },
    level:  () => { sweep({from:660,to:990,dur:0.15,vol:0.6}); setTimeout(()=>sweep({from:740,to:1200,dur:0.18,vol:0.6}), 160); },
    over:   () => { sweep({from:300,to:140,dur:0.4,type:'triangle',vol:0.7}); }
  };
  const gesture = () => { ensureAudio(); window.removeEventListener('keydown', gesture); window.removeEventListener('pointerdown', gesture); };
  window.addEventListener('keydown', gesture, {once:true});
  window.addEventListener('pointerdown', gesture, {once:true});

  // --- Modes config ---
  const MODES = {
    classic: {
      lives: 3,
      paddle: { w:96, h:10, y:H-40, speed:6 },
      ball:   { r:4, vx:3, vy:-3, maxSpeed:6 },
      grid:   { cols:14, rows:8, wCalc:(W-2*20), h:18, gap:2, ox:20, oy:70 },
      colors: ["#ff3b30","#ff3b30","#ff8c00","#ff8c00","#2ecc71","#2ecc71","#ffd400","#ffd400"],
      scores: [50,50,30,30,20,20,10,10]
    },
    easy: {
      lives: 5,
      paddle: { w:150, h:12, y:H-40, speed:6 },
      ball:   { r:8, vx:2.4, vy:-2.4, maxSpeed:4.8 },
      grid:   { cols:8, rows:3, wCalc:(W-2*20), h:32, gap:4, ox:20, oy:120 },
      colors: ["#ff3b30","#ff8c00","#ffd400"],
      scores: [50,30,10]
    }
  };

  // --- Game state (will be reinitialised per mode) ---
  const state = {
    mode: 'classic',
    score:0, lives:3, won:false, over:false,
    paddle:{ w:96, h:10, x:(W-96)/2, y:H-40, speed:6 },
    ball:{ x:W/2, y:H-60, r:4, vx:3, vy:-3, stuck:true, maxSpeed:6 },
    bricks:[], keys:{ left:false, right:false }
  };

  // UI helpers
  function setActiveModeButton(){
    const isClassic = state.mode==='classic';
    btnClassic.classList.toggle('active', isClassic);
    btnClassic.setAttribute('aria-pressed', isClassic?'true':'false');
    btnEasy.classList.toggle('active', !isClassic);
    btnEasy.setAttribute('aria-pressed', !isClassic?'true':'false');
  }
  btnClassic.addEventListener('click', () => { if (state.mode!=='classic'){ switchMode('classic'); } });
  btnEasy.addEventListener('click', () => { if (state.mode!=='easy'){ switchMode('easy'); } });

  function switchMode(next){
    state.mode = next;
    configureFromMode();
    setActiveModeButton();
  }

  function configureFromMode(){
    const M = MODES[state.mode];
    state.score = 0;
    state.lives = M.lives;
    state.won = false;
    state.over = false;
    state.paddle.w = M.paddle.w; state.paddle.h = M.paddle.h; state.paddle.y = M.paddle.y; state.paddle.speed = M.paddle.speed;
    state.paddle.x = (W - state.paddle.w) / 2;
    state.ball.r = M.ball.r; state.ball.vx = M.ball.vx; state.ball.vy = M.ball.vy; state.ball.maxSpeed = M.ball.maxSpeed;
    state.ball.stuck = true;
    buildBricks();
    updateHUD();
    hideWin(); hideOver();
    render();
  }

  function buildBricks(){
    const M = MODES[state.mode];
    const g = M.grid;
    const bw = Math.floor(g.wCalc / g.cols);
    state.bricks = [];
    for(let r=0;r<g.rows;r++){
      for(let c=0;c<g.cols;c++){
        state.bricks.push({
          x: g.ox + c*(bw+g.gap),
          y: g.oy + r*(g.h+g.gap),
          w: bw, h: g.h, hit:false,
          color: M.colors[r], value: M.scores[r]
        });
      }
    }
  }

  function resetBall(serveRight=false){
    const p=state.paddle, b=state.ball;
    b.x = p.x + p.w/2; b.y = p.y - Math.max(10, b.r+2);
    const M = MODES[state.mode];
    b.vx = serveRight ? Math.abs(M.ball.vx) : -Math.abs(M.ball.vx);
    b.vy = -Math.abs(M.ball.vy);
    b.stuck = true;
  }

  function resetGame(){
    configureFromMode();
    resetBall();
  }

  function showWin(){ winScore.textContent = `SCORE ${String(state.score).padStart(4,'0')}`; winOverlay.classList.add('show'); }
  function hideWin(){ winOverlay.classList.remove('show'); }
  function showOver(){ overScore.textContent = `SCORE ${String(state.score).padStart(4,'0')}`; overOverlay.classList.add('show'); }
  function hideOver(){ overOverlay.classList.remove('show'); }

  function updateHUD(){
    scoreLbl.textContent = `SCORE ${String(state.score).padStart(4,'0')}`;
    livesLbl.textContent = `BALLS ${state.lives}`;
  }

  // Input
  addEventListener('keydown',e=>{
    if (e.code==='ArrowLeft' || e.key==='a' || e.key==='A') state.keys.left=true;
    if (e.code==='ArrowRight'|| e.key==='d' || e.key==='D') state.keys.right=true;
    if (e.code==='Space'){
      if (state.won || state.over){ resetGame(); }
      else if (state.ball.stuck) { state.ball.stuck=false; }
      e.preventDefault();
    }
    if (e.key==='r' || e.key==='R') resetGame();
  });
  addEventListener('keyup',e=>{
    if (e.code==='ArrowLeft' || e.key==='a' || e.key==='A') state.keys.left=false;
    if (e.code==='ArrowRight'|| e.key==='d' || e.key==='D') state.keys.right=false;
  });

  // Helpers
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function aabbIntersect(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  function collideBricksAxis(axis){
    const b=state.ball;
    const half=b.r;
    const bx = Math.round(b.x - half), by = Math.round(b.y - half), bs = half*2;
    for (const br of state.bricks){
      if (br.hit) continue;
      if (aabbIntersect(bx, by, bs, bs, br.x, br.y, br.w, br.h)){
        br.hit = true;
        state.score += br.value;
        updateHUD();
        sounds.brick();
        if (axis==='x'){
          if (b.vx > 0) b.x = br.x - half; else b.x = br.x + br.w + half;
          b.vx *= -1;
        } else {
          if (b.vy > 0) b.y = br.y - half; else b.y = br.y + br.h + half;
          b.vy *= -1;
        }
        return true;
      }
    }
    return false;
  }

  function step(){
    const p=state.paddle, b=state.ball;
    if (state.won || state.over) return;

    if (state.keys.left ^ state.keys.right){
      p.x += state.keys.left ? -p.speed : p.speed;
    }
    p.x = clamp(p.x, PLAY_L+1, PLAY_R-1 - p.w);

    if (b.stuck){ b.x = p.x + p.w/2; b.y = p.y - Math.max(10, b.r+2); }

    const sp = Math.hypot(b.vx,b.vy);
    const max = state.ball.maxSpeed;
    if (sp > max){
      const s = max / sp; b.vx *= s; b.vy *= s;
    }

    b.x += b.stuck ? 0 : b.vx;
    if (b.x - b.r < PLAY_L){ b.x = PLAY_L + b.r; b.vx *= -1; sounds.wall(); }
    if (b.x + b.r > PLAY_R){ b.x = PLAY_R - b.r; b.vx *= -1; sounds.wall(); }
    collideBricksAxis('x');

    b.y += b.stuck ? 0 : b.vy;
    if (b.y - b.r < PLAY_T){ b.y = PLAY_T + b.r; b.vy *= -1; sounds.wall(); }

    if (b.vy > 0){
      if (aabbIntersect(b.x-b.r, b.y-b.r, b.r*2, b.r*2, p.x, p.y, p.w, p.h)){
        b.y = p.y - b.r;
        b.vy = -Math.abs(b.vy);
        const rel = (b.x - (p.x + p.w/2)) / (p.w/2);
        const angleScale = state.mode==='classic' ? 5.0 : 4.0;
        b.vx = rel * angleScale;
        const speed = Math.hypot(b.vx,b.vy);
        const target = Math.min(speed*1.02, state.ball.maxSpeed);
        const k = target / speed;
        b.vx *= k; b.vy *= k;
        sounds.paddle(rel);
      }
    }
    collideBricksAxis('y');

    if (b.y - b.r > PLAY_B){
      state.lives -= 1; updateHUD(); sounds.life();
      if (state.lives <= 0){
        state.over = true; b.stuck = true; sounds.over();
        overScore.textContent = `SCORE ${String(state.score).padStart(4,'0')}`;
        overOverlay.classList.add('show');
        return;
      }
      resetBall(Math.random()>0.5);
    }

    if (state.bricks.every(br=>br.hit)){
      state.won = true; b.stuck = true; sounds.level(); showWin();
    }
  }

  function render(){
    ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle="#444"; ctx.lineWidth=1; ctx.strokeRect(PLAY_L+0.5,PLAY_T+0.5, (PLAY_R-PLAY_L)-1, (PLAY_B-PLAY_T)-1);

    for (const br of state.bricks){
      if (br.hit) continue;
      ctx.fillStyle = br.color;
      ctx.fillRect(br.x, br.y, br.w, br.h);
    }

    const p=state.paddle, b=state.ball;
    ctx.fillStyle="#fff"; ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.fillRect(Math.round(b.x-b.r), Math.round(b.y-b.r), b.r*2, b.r*2);

    ctx.strokeStyle="#666"; ctx.lineWidth=2; ctx.strokeRect(1,1,W-2,H-2);
  }

  let last=performance.now();
  function loop(ts){
    if (ts - last > 1000/240){ step(); last = ts; }
    render();
    requestAnimationFrame(loop);
  }

  configureFromMode();
  render(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
